trigger:
  branches:
    include:
      - master
  paths:
    include:
      - app/* 
      - k8s/*
      - infra-pipelines/app-pipeline.yaml

pool:
  name: 'banco-pichincha'

variables:
  dockerRegistryServiceConnection: 'DockerHub-Connection' 
  imageRepository: 'brandon2399/devops-challenge'
  containerRegistry: 'docker.io'
  dockerfilePath: '$(Build.SourcesDirectory)/app/Dockerfile'
  tag: '$(Build.BuildId)'

  # Lo ideal es obtenerla dinámicamente
  k8sMasterIP: 13.218.91.114
  sshKeySecureFile: 'devops-key.pem'

stages:
- stage: CI
  displayName: Build and Push
  jobs:
  - job: Build
    displayName: Build
    steps:
    - script: |
        python3 -m pip install --upgrade pip
        pip3 install -r app/requirements.txt
        pip3 install pytest httpx
      displayName: 'Instalar Dependencias'

    - script: |
        # Ejecutar pruebas unitarias (Requisito TDD)
        # pytest # Descomenta esto cuando creemos los tests reales
        cd app
        python3 -m pytest
      displayName: 'Ejecutar Pruebas Unitarias (Pytest)'

    - task: Docker@2
      displayName: Build and Push to Docker Hub
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest

- stage: CD
  displayName: Deploy to K8s
  dependsOn: CI
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: Deploy
    displayName: Deploy via SSH
    steps:
    - task: DownloadSecureFile@1
      name: sshKey
      displayName: 'Descargar Llave PEM'
      inputs:
        secureFile: '$(sshKeySecureFile)'

    - script: |
        # Configurar permisos de la llave
        chmod 400 $(sshKey.secureFilePath)
        
        # Conexión SSH para desplegar en Kind
        # 1. Actualizamos la imagen en el deployment (si existe) o creamos los recursos
        # Usamos StrictHostKeyChecking=no para evitar el prompt de confirmación
        
        ssh -o StrictHostKeyChecking=no -i $(sshKey.secureFilePath) ubuntu@$(k8sMasterIP) "
          # Aseguramos que Kind esté respondiendo
          export KUBECONFIG=/home/ubuntu/.kube/config
          
          # Crear Deployment si no existe (Un comando simple imperative para el examen)
          # En un mundo real copiaríamos los YAMLs, aquí forzamos la actualización de imagen
          
          kubectl create deployment devops-api --image=$(imageRepository):$(tag) --dry-run=client -o yaml > deployment.yaml
          
          # Agregamos configuración de escalado y puertos al yaml generado (truco rápido)
          echo '---' >> deployment.yaml
          kubectl create service nodeport devops-api --tcp=80:8000 --node-port=30000 --dry-run=client -o yaml >> deployment.yaml
          
          # Aplicar cambios
          kubectl apply -f deployment.yaml
          
          # Forzar actualización de imagen si el deployment ya existía
          kubectl set image deployment/devops-api devops-api=$(imageRepository):$(tag)
          
          # Verificar estado
          kubectl rollout status deployment/devops-api
        "
      displayName: 'Desplegar en Kubernetes Remoto'