trigger:
  branches:
    include:
      - master
  paths:
    include:
      - app/* 
      - k8s/*
      - infra-pipelines/app-pipeline.yaml

pool:
  name: 'banco-pichincha'

variables:
  dockerRegistryServiceConnection: 'DockerHub-Connection' 
  imageName: 'brandon2399/devops-challenge'
  containerRegistry: 'docker.io'
  dockerfilePath: '$(Build.SourcesDirectory)/app/Dockerfile'
  tag: '$(Build.BuildId)'
  k8sMasterIP: 13.218.91.114
  sshKeySecureFile: 'devops-key.pem'

stages:
- stage: CI
  displayName: Continuous Integration
  jobs:
  - job: CI_Pipeline
    displayName: Security -> Test -> Build
    steps:
    
    # ---CHECKOUT---
    - checkout: self
      displayName: '0. Descargar Código Fuente (Checkout)'
      clean: true
      fetchDepth: 1

    # --- STATIC CODE REPORT XML (TRIVY) ---
    - script: |
        echo ">>> INICIANDO REVISIÓN ESTÁTICA CON TRIVY <<<"
        
        # Instalación de Trivy
        if ! command -v trivy &> /dev/null; then
            echo "Instalando Trivy..."
            sudo apt-get install wget apt-transport-https gnupg lsb-release -y
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update
            sudo apt-get install trivy -y
        fi
        
        echo "Ejecutando escaneo y generando reporte JUnit..."
        # Ejecutamos Trivy, forzamos formato JUnit y guardamos el resultado en un archivo XML
        # Usamos $(System.DefaultWorkingDirectory) para la ruta del archivo
        trivy fs . \
        --severity HIGH,CRITICAL \
        --format junit \
        --output $(System.DefaultWorkingDirectory)/trivy-report.xml \
        --no-progress
        
      displayName: '1.1 Static Code Revision (Trivy) & Generate JUnit'

    # --- PUBLISH'TESTS' ---
    - task: PublishTestResults@2
      displayName: '1.2 Publish Security Report to Tests Tab'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/trivy-report.xml' 
        mergeTestResults: true
        testRunTitle: 'Trivy Security Report (Build $(Build.BuildId))'
        failTaskOnFailedTests: false 
    # ----------------------------------------------------------------------
    
    # ---  BUILD & TEST (PYTHON) ---
    - script: |
        echo ">>> PREPARANDO ENTORNO PYTHON <<<"
        python3 -m pip install --upgrade pip
        pip3 install -r app/requirements.txt
        pip3 install pytest httpx
        
        echo ">>> EJECUTANDO PRUEBAS AUTOMÁTICAS (TDD) <<<"
        cd app
        python3 -m pytest
      displayName: '2. Automatic Testing (Pytest)'

    # --- DOCKER BUILD & PUSH ---
    - task: Docker@2
      displayName: '3. Build and Push Docker Image'
      inputs:
        command: buildAndPush
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageName)
        dockerfile: app/Dockerfile
        tags: |
          $(Build.BuildId)
          latest
- stage: CD
  displayName: Deploy K8s in EC2
  dependsOn: CI
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: Deploy
    displayName: Deploy via SSH
    steps:
    - task: DownloadSecureFile@1
      name: sshKey
      displayName: 'Descargar Llave PEM'
      inputs:
        secureFile: '$(sshKeySecureFile)'

    - script: |
        chmod 400 $(sshKey.secureFilePath)
        
        ssh -o StrictHostKeyChecking=no -i $(sshKey.secureFilePath) ubuntu@$(k8sMasterIP) "
          
          # 1. Configurar Kind
          cat <<EOF > kind-config.yaml
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        nodes:
        - role: control-plane
          extraPortMappings:
          - containerPort: 30000
            hostPort: 30000
        - role: worker
        EOF

          # 2. Crear Cluster si no existe
          # Usamos 'kind' como nombre por defecto
          if ! sudo kind get clusters | grep -q 'kind'; then
            echo 'Creando cluster...'
            sudo kind create cluster --config kind-config.yaml
          fi

          # ### FIX IMPORTANTE: OBTENER LAS CREDENCIALES ###
          # 1. Crear carpeta .kube si no existe
          mkdir -p /home/ubuntu/.kube
          
          # 2. Extraer el kubeconfig del cluster (aunque sea de root) y guardarlo en el usuario ubuntu
          sudo kind get kubeconfig --name kind > /home/ubuntu/.kube/config
          
          # 3. Dar permisos al usuario ubuntu para leer ese archivo
          sudo chown ubuntu:ubuntu /home/ubuntu/.kube/config
          chmod 600 /home/ubuntu/.kube/config
          
          # 4. Decirle a kubectl dónde está el archivo
          export KUBECONFIG=/home/ubuntu/.kube/config
          # ##############################################

          # 3. Generar Manifiestos HPA agregado para Dynamic Grow
          echo 'Generando manifiestos...'
          cat <<EOF > app.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: devops-api
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: devops-api
          template:
            metadata:
              labels:
                app: devops-api
            spec:
              containers:
              - name: devops-api
                image: $(imageName):$(Build.BuildId)
                imagePullPolicy: Always
                ports:
                - containerPort: 8000
                resources:
                  limits:
                    memory: '256Mi'
                    cpu: '500m'
                  requests:
                    memory: '128Mi'
                    cpu: '250m'
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: devops-api-service
        spec:
          type: NodePort
          selector:
            app: devops-api
          ports:
          - protocol: TCP
            port: 80
            targetPort: 8000
            nodePort: 30000
        ---
        apiVersion: autoscaling/v1
        kind: HorizontalPodAutoscaler
        metadata:
          name: devops-api-hpa
        spec:
          scaleTargetRef:
            apiVersion: apps/v1
            kind: Deployment
            name: devops-api
          minReplicas: 2
          maxReplicas: 5
          targetCPUUtilizationPercentage: 70
        EOF

          # 4. Desplegar
          echo 'Aplicando configuración en Kubernetes...'
          kubectl apply -f app.yaml
          
          echo 'Actualizando imagen...'
          kubectl set image deployment/devops-api devops-api=$(imageName):$(Build.BuildId)
          
          echo 'Esperando despliegue...'
          kubectl rollout status deployment/devops-api
          
          echo '¡ÉXITO!'
        "
      displayName: 'Desplegar en Kubernetes Remoto'